main:
  params: [input]
  steps:
    # Step 1: Parse firewall_id
    - parseFirewallId:
        assign:
          - firewall_id: ${input.FirewallId}
          - parts: ${text.split(firewall_id, "/")}

    - logInput:
        call: sys.log
        args:
          text: ${"Runbook started. Received parameter firewall_id = '" + firewall_id + "'"}
          severity: INFO

    - validateParts:
        switch:
          - condition: ${len(parts) < 5}
            raise:
              status_code: "error"
              message: ${"Invalid FirewallId format. Expected 'projects/<project_id>/global/firewalls/<firewall_name>', got; " + firewall_id}

    - extractIds:
        assign:
          - project_id: ${parts[1]}
          - firewall_name: ${parts[4]}

    # Step 2: Get firewall
    - getRule:
        try:
            call: googleapis.compute.v1.firewalls.get
            args:
                project: ${project_id}
                firewall: ${firewall_name}
            result: fw
        except:
          as: e
          switch:
            - condition: ${e.body.error.code != 409}
              raise:
                status_code: "error"
                message: ${e.body.error.message}

    # Step 3: If already disabled
    - checkDisabled:
        switch:
          - condition: ${fw.disabled == true}
            next: alreadyDisabled
        next: skipIfNotPublic

    - alreadyDisabled:
        return:
          status_code: "ok"
          message: ${"Firewall rule " + firewall_name + " is already disabled."}

    - skipIfNotPublic:
        switch:
          - condition: ${not("0.0.0.0/0" in fw.sourceRanges)}
            next: noChange

    # Step 5: Init flags
    - initFlags:
        assign:
          - hasTcpAll: false
          - onlyTcpAll: false
          - hasOtherProtocols: false
          - newAllowed: []
          - i: 0

    # Step 6: Loop over allowed
    - loopAllowed:
        switch:
          - condition: ${i < len(fw.allowed)}
            next: setRule
        next: finishCheck

    - setRule:
        assign:
          - rule: ${fw.allowed[i]}
        next: checkProtocol

    # Protocol handling
    - checkProtocol:
        switch:
          - condition: ${rule.IPProtocol == "all"}
            next: splitAll
          - condition: ${rule.IPProtocol == "tcp"}
            next: checkPorts
        next: markOther

    # Split "all" â†’ keep everything except tcp all
    - splitAll:
        assign:
            - hasTcpAll: true
            - hasOtherProtocols: true
            - newAllowed: []
            - k: 0
        next: loopOther

    - loopOther:
        switch:
          - condition: ${k >= len(fw.allowed)}
            next: nextIter

    - checkOther:
        switch:
          - condition: ${fw.allowed[k].IPProtocol != "tcp" and fw.allowed[k].IPProtocol != "all"}
            next: addOther

    - nextOther:
        assign:
          - k: ${k + 1}
        next: loopOther

    - addOther:
        assign:
          - newAllowed: ${list.concat(newAllowed, [fw.allowed[k]])}
        next: nextOther

    - checkPorts:
        switch:
          - condition: ${"1-65535" in rule.ports or "0-65535" in rule.ports}
            next: markTcpAll
        next: keepRule

    - markTcpAll:
        assign:
          - hasTcpAll: true
          - onlyTcpAll: true
        next: nextIter

    - markOther:
        assign:
          - hasOtherProtocols: true
        next: keepRule

    - keepRule:
        assign:
          - newAllowed: ${list.concat(newAllowed, [rule])}
        next: nextIter

    - nextIter:
        assign:
          - i: ${i + 1}
        next: loopAllowed

    # Step 7: Decide
    - finishCheck:
        switch:
          - condition: ${hasTcpAll and onlyTcpAll and not hasOtherProtocols}
            next: disableRule
          - condition: ${hasTcpAll}
            next: patchRule
        next: noChange

    # Step 8a: Disable if only TCP all
    - disableRule:
        try:
          call: googleapis.compute.v1.firewalls.patch
          args:
            project: ${project_id}
            firewall: ${firewall_name}
            body:
              name: ${fw.name}
              network: ${fw.network}
              direction: ${fw.direction}
              priority: ${fw.priority}
              sourceRanges: ${fw.sourceRanges}
              targetTags: ${fw.targetTags}
              allowed: ${fw.allowed}
              disabled: true
        except:
          as: e
          raise:
            status_code: "error"
            message: ${e.body.error.message}
        next: done

    # Step 8b: Patch (after splitAll / remove tcp)
    - patchRule:
        try:
          call: googleapis.compute.v1.firewalls.patch
          args:
            project: ${project_id}
            firewall: ${firewall_name}
            body:
              name: ${fw.name}
              network: ${fw.network}
              direction: ${fw.direction}
              priority: ${fw.priority}
              sourceRanges: ${fw.sourceRanges}
              targetTags: ${fw.targetTags}
              allowed: ${newAllowed}
        except:
          as: e
          raise:
            status_code: "error"
            message: ${e.body.error.message}
        next: done

    # Step 9: No change
    - noChange:
        return:
          status_code: "ok"
          message: ${"Firewall rule " + firewall_name + " does not allow all TCP ports publicly."}

    - done:
        return:
          status_code: "success"
          message: ${"Firewall rule " + firewall_name + " disabled or patched successfully"}
